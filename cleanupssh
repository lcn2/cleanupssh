#!/bin/bash
#
# cleanupssh - cleanup a .ssh directory
#
# Copyright (c) 2015-2019 by Landon Curt Noll.  All Rights Reserved.
#
# Permission to use, copy, modify, and distribute this software and
# its documentation for any purpose and without fee is hereby granted,
# provided that the above copyright, this permission notice and text
# this comment, and the disclaimer below appear in all of the following:
#
#       supporting documentation
#       source copies
#       source works derived from this source
#       binaries derived from this source or from derived source
#
# LANDON CURT NOLL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
# EVENT SHALL LANDON CURT NOLL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
# USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.
#
# chongo (Landon Curt Noll, http://www.isthe.com/chongo/index.html) /\oo/\
#
# Share and enjoy! :-)

# parse args
#
export VERSION="3.1"
export USAGE="usage: $0 [-n] [-v] [-f] [-i] [-s] [-c user[:group]] [-V] [-h] dir

    -n		Do nothing (def: do)
    -v		Verbose mode (def: quiet)
    -f		Force cleanup if missing: authorized_keys config id_rsa id_rsa.pub known_hosts
    -i		Do not warn if missing:   authorized_keys config id_rsa id_rsa.pub known_hosts
		    NOTE: -i implies -f
    -s		Do not unique sort authorized_keys (def: do)

    -c user[:group]	Chown critical files as user:group (def: do not chown)
			    NOTE: Ignored if UID != 0 (i.e., not root)

    -V		Print version and exit
    -h		Print this mdssage and exit

    dir		The .ssh directory to clean up

    Version: $VERSION"
export N_FLAG=
export V_FLAG=
export XARGS_V=
export F_FLAG=
export I_FLAG=
export S_FLAG=
export USER_GROUP=
while getopts hnvfisc:V flag; do
    case "$flag" in
    h) echo "$USAGE" 1>&2; exit 0 ;;
    n) N_FLAG="-n" ;;
    v) V_FLAG="-v" ; XARGS_V="-t" ;;
    f) F_FLAG="-f" ;;
    i) I_FLAG="-i"; F_FLAG="-f" ;;
    s) S_FLAG="-s" ;;
    c) USER_GROUP="$OPTARG" ;;
    V) echo "$0: Version: $VERSION" ; exit 0 ;;
    ?) echo "$0: FATAL: unknown or invalid -flag" 1>&2 ;
       echo "$USAGE" 1>&2 ;
       exit 1 ;;
    esac
done
shift $(( OPTIND - 1 ));
if [[ $# -ne 1 ]]; then
   echo "$USAGE" 1>&2 ;
   exit 2
fi
export dir="$1"
if [[ -z "${OS}" ]]; then
    export OS=$(uname | tr '[A-Z]' '[a-z]')
fi
if [[ -n $USER_GROUP ]]; then
    if [[ -z $UID ]]; then
	export UID="$(/usr/bin/id -u)"
    fi
    if [[ $UID -ne 0 ]]; then
	if [[ -z $I_FLAG ]]; then
	    echo "$0: Warning: because UID: $UID != 0, ignoring: -c $USER_GROUP" 1>&2
	fi
	USER_GROUP=
    fi
fi

# firewall
#
if [[ -n "$V_FLAG" ]]; then
    echo '# Move into the directory'
fi
if [[ ! -d "$dir" ]]; then
    if [[ -z "$F_FLAG" ]]; then
	echo "$0: FATAL: not a directory: $dir" 1>&2
	exit 3
    else
	if [[ -n "$V_FLAG" ]]; then
	    echo "mkdir -p --mode=0700 $dir"
	fi
	mkdir -p --mode=0700 "$dir"
	if [[ ! -d "$dir" ]]; then
	    echo "$0: FATAL: cannot make directory: $dir" 1>&2
	    exit 4
	fi
    fi
fi
if [[ -z "$N_FLAG" && ! -w "$dir" ]]; then
    echo "$0: FATAL: directory not writable: $dir" 1>&2
    exit 5
fi
if [[ -n "$V_FLAG" ]]; then
    echo "cd $dir"
fi
cd "$dir"
status="$?"
if [[ $status -ne 0 ]]; then
    echo "$0: FATAL: cd $dir, error code: $status" 1>&2
    exit 6
fi
if [[ -z "$F_FLAG" && ! -f authorized_keys ]]; then
    echo "$0: FATAL: $dir is missing authorized_keys" 1>&2
    exit 7
fi
if [[ -z "$F_FLAG" && ! -f id_rsa ]]; then
    echo "$0: FATAL: $dir is missing id_rsa" 1>&2
    exit 8
fi
if [[ -z "$F_FLAG" && ! -f id_rsa.pub ]]; then
    echo "$0: FATAL: $dir is missing id_rsa.pub" 1>&2
    exit 9
fi
if [[ -n "$V_FLAG" ]]; then
    echo
fi

# form missing critical directories
#
if [[ -n "$V_FLAG" ]]; then
    echo '# Processing critical directories'
fi
if [[ ! -d sock ]]; then
    if [[ -z "$N_FLAG" ]]; then
	mkdir $V_FLAG sock
	status="$?"
	if [[ ! -d sock ]]; then
	    echo "$0: FATAL cannot mkdir sock, error code: $status" 1>&2
	    exit 10
	fi
    elif [[ -n "$V_FLAG" ]]; then
	echo mkdir $V_FLAG sock
    fi
fi
if [[ -z "$N_FLAG" ]]; then
    chmod $V_FLAG 0700 sock
    status="$?"
    if [[ $status -ne 0 ]]; then
	echo "$0: FATAL: chmod 0700 sock, error code: $status" 1>&2
	exit 11
    fi
elif [[ -n "$V_FLAG" ]]; then
    echo chmod $V_FLAG 0700 sock
fi 2>&1 | grep -v ' retained as '
if [[ -z "$N_FLAG" && ! -w sock ]]; then
    echo "$0: FATAL: directory not writable: sock" 1>&2
    exit 12
fi
if [[ ! -d OLD ]]; then
    if [[ -z "$N_FLAG" ]]; then
	mkdir $V_FLAG OLD
	status="$?"
	if [[ ! -d OLD ]]; then
	    echo "$0: FATAL cannot mkdir OLD, error code: $status" 1>&2
	    exit 13
	fi
    elif [[ -n "$V_FLAG" ]]; then
	echo mkdir $V_FLAG OLD
    fi
fi
if [[ -z "$N_FLAG" ]]; then
    chmod $V_FLAG 0700 OLD
    status="$?"
    if [[ $status -ne 0 ]]; then
	echo "$0: FATAL: chmod 0700 OLD, error code: $status" 1>&2
	exit 14
    fi
elif [[ -n "$V_FLAG" ]]; then
    echo chmod $V_FLAG 0700 OLD
fi 2>&1 | grep -v ' retained as '
if [[ -z "$N_FLAG" && ! -w OLD ]]; then
    echo "$0: FATAL: directory not writable: OLD" 1>&2
    exit 15
fi
if [[ ! -d from ]]; then
    if [[ -z "$N_FLAG" ]]; then
	mkdir $V_FLAG from
	status="$?"
	if [[ ! -d from ]]; then
	    echo "$0: FATAL cannot mkdir from, error code: $status" 1>&2
	    exit 16
	fi
    elif [[ -n "$V_FLAG" ]]; then
	echo mkdir $V_FLAG from
    fi
fi
if [[ -z "$N_FLAG" ]]; then
    chmod $V_FLAG 0700 from
    status="$?"
    if [[ $status -ne 0 ]]; then
	echo "$0: FATAL: chmod 0700 from, error code: $status" 1>&2
	exit 17
    fi
elif [[ -n "$V_FLAG" ]]; then
    echo chmod $V_FLAG 0700 from
fi 2>&1 | grep -v ' retained as '
if [[ -z "$N_FLAG" && ! -w from ]]; then
    echo "$0: FATAL: directory not writable: from" 1>&2
    exit 18
fi
if [[ -n "$V_FLAG" ]]; then
    echo
fi

# unless -s, be sure that authorized_keys is in canonical order
#
if [[ -z $S_FLAG ]]; then
    if [[ -n "$V_FLAG" ]]; then
	echo '# Canonical order processing on authorized_keys'
    fi
    #
    export SORTED_TMP=
    if [[ -z "$N_FLAG" ]]; then
	SORTED_TMP=$(mktemp sorted-authorized_keys.XXXXXX)
	if [[ -z $SORTED_TMP || ! -w $SORTED_TMP ]]; then
	    echo "$0: FATAL: cannot create a temporary writable file" 1>&2
	    exit 19
	fi
	trap 'rm -f -- "$SORTED_TMP"' 0 1 2 3 15
    else
	SORTED_TMP=$(mktemp -u sorted-authorized_keys.XXXXXX)
    fi
    if [[ -n "$V_FLAG" ]]; then
	echo sort -u -k3 authorized_keys -o "$SORTED_TMP"
    fi
    if [[ -z "$N_FLAG" ]]; then
	sort -u -k3 authorized_keys -o "$SORTED_TMP"
	status="$?"
    else
	status=0
    fi
    if [[ $status -ne 0 ]]; then
	echo "$0: FATAL: sort -u -k3 authorized_keys -o $SORTED_TMP, error code: $status" 1>&2
	exit 20
    fi
    #
    if cmp -s authorized_keys "$SORTED_TMP"; then
	if [[ -n "$V_FLAG" ]]; then
	    echo rm -f "$SORTED_TMP"
	fi
	if [[ -z "$N_FLAG" ]]; then
	    rm -f "$SORTED_TMP"
	fi
    else
	if [[ -n "$USER_GROUP" ]]; then
	    if [[ -n "$V_FLAG" ]]; then
		echo chown "$V_FLAG" "$USER_GROUP" "$SORTED_TMP"
	    fi
	    if [[ -z "$N_FLAG" ]]; then
		chown $V_FLAG "$USER_GROUP" "$SORTED_TMP"
		status="$?"
	    else
		status=0
	    fi 2>&1 | grep -v ' retained as '
	    if [[ $status -ne 0 ]]; then
		echo "$0: FATAL: chown $USER_GROUP $SORTED_TMP, error code: $status" 1>&2
		exit 21
	    fi
	fi
	if [[ -n "$V_FLAG" ]]; then
	    echo chmod "$V_FLAG" 0400 "$SORTED_TMP"
	fi
	if [[ -z "$N_FLAG" ]]; then
	    chmod $V_FLAG 0400 "$SORTED_TMP"
	    status="$?"
	    if [[ $status -ne 0 ]]; then
		echo "$0: FATAL: chmod 0400 $SORTED_TMP, error code: $status" 1>&2
		exit 22
	    fi
	fi 2>&1 | grep -v ' retained as '
	if [[ -n "$V_FLAG" ]]; then
	    echo mv -f "$V_FLAG" "$SORTED_TMP" authorized_keys
	fi
	if [[ -z "$N_FLAG" ]]; then
	    mv -f $V_FLAG "$SORTED_TMP" authorized_keys
	    status="$?"
	    if [[ $status -ne 0 ]]; then
		echo "$0: FATAL: mv -f $V_FLAG $SORTED_TMP SORTED_TMP, error code: $status" 1>&2
		exit 23
	    fi
	fi
    fi
else
    if [[ -n "$V_FLAG" ]]; then
	echo '# Disabled canonical order check on canonical order due to -s flag'
    fi
fi
if [[ -n "$V_FLAG" ]]; then
    echo
fi

# set file permissions
#
if [[ -n "$V_FLAG" ]]; then
    echo '# Processing fileset permissions'
fi
if [[ -z "$N_FLAG" ]]; then
    chmod $V_FLAG 0700 .
    SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'authorized_keys*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f -name 'authorized_keys*' -print0 |
	  xargs $XARGS_V -0 chmod $V_FLAG 0400
    fi
    SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'config*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f -name 'config*' -print0 |
	  xargs $XARGS_V -0 chmod $V_FLAG 0400
    fi
    SET=$(find . -mindepth 1 -maxdepth 1 -type f ! -name 'id_rsa.pub*' -name 'id_rsa*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f ! -name 'id_rsa.pub*' -name 'id_rsa*' -print0 |
	  xargs $XARGS_V -0 chmod $V_FLAG 0400
    fi
    SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'id_rsa.pub*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f -name 'id_rsa.pub*' -print0 |
	  xargs $XARGS_V -0 chmod $V_FLAG 0444
    fi
    SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'known_hosts*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f -name 'known_hosts*' -print0 |
	  xargs $XARGS_V -0 chmod $V_FLAG 0664
    fi
elif [[ -n "$V_FLAG" ]]; then
    echo chmod $V_FLAG 0700 .
    SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'authorized_keys*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f -name 'authorized_keys*' -print0 |
	  xargs -0 echo chmod $V_FLAG 0400
    fi
    SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'config*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f -name 'config*' -print0 |
	  xargs -0 echo chmod $V_FLAG 0400
    fi
    SET=$(find . -mindepth 1 -maxdepth 1 -type f ! -name 'id_rsa.pub*' -name 'id_rsa*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f ! -name 'id_rsa.pub*' -name 'id_rsa*' -print0 |
	  xargs -0 echo chmod $V_FLAG 0400
    fi
    SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'id_rsa.pub*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f -name 'id_rsa.pub*' -print0 |
	  xargs -0 echo chmod $V_FLAG 0444
    fi
    SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'known_hosts*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f -name 'known_hosts*' -print0 |
	  xargs -0 echo chmod $V_FLAG 0664
    fi
fi 2>&1 | grep -v ' retained as '
if [[ -n "$V_FLAG" ]]; then
    echo
fi

# set file ownership
#
if [[ -n "$USER_GROUP" ]]; then
    if [[ -n "$V_FLAG" ]]; then
	echo '# Processing fileset ownerships'
    fi
    if [[ -z "$N_FLAG" ]]; then
	chown $V_FLAG "$USER_GROUP" .
	SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'authorized_keys*' -print)
	if [[ -n $SET ]]; then
	    find . -mindepth 1 -maxdepth 1 -type f -name 'authorized_keys*' -print0 |
	      xargs $XARGS_V -0 chown $V_FLAG "$USER_GROUP"
	fi
	SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'config*' -print)
	if [[ -n $SET ]]; then
	    find . -mindepth 1 -maxdepth 1 -type f -name 'config*' -print0 |
	      xargs $XARGS_V -0 chown $V_FLAG "$USER_GROUP"
	fi
	SET=$(find . -mindepth 1 -maxdepth 1 -type f ! -name 'id_rsa.pub*' -name 'id_rsa*' -print)
	if [[ -n $SET ]]; then
	    find . -mindepth 1 -maxdepth 1 -type f ! -name 'id_rsa.pub*' -name 'id_rsa*' -print0 |
	      xargs $XARGS_V -0 chown $V_FLAG "$USER_GROUP"
	fi
	SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'id_rsa.pub*' -print)
	if [[ -n $SET ]]; then
	    find . -mindepth 1 -maxdepth 1 -type f -name 'id_rsa.pub*' -print0 |
	      xargs $XARGS_V -0 chown $V_FLAG "$USER_GROUP"
	fi
	SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'known_hosts*' -print)
	if [[ -n $SET ]]; then
	    find . -mindepth 1 -maxdepth 1 -type f -name 'known_hosts*' -print0 |
	      xargs $XARGS_V -0 chown $V_FLAG "$USER_GROUP"
	fi
    elif [[ -n "$V_FLAG" ]]; then
	echo chown $V_FLAG "$USER_GROUP" .
	SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'authorized_keys*' -print)
	if [[ -n $SET ]]; then
	    find . -mindepth 1 -maxdepth 1 -type f -name 'authorized_keys*' -print0 |
	      xargs -0 echo chown $V_FLAG "$USER_GROUP"
	fi
	SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'config*' -print)
	if [[ -n $SET ]]; then
	    find . -mindepth 1 -maxdepth 1 -type f -name 'config*' -print0 |
	      xargs -0 echo chown $V_FLAG "$USER_GROUP"
	fi
	SET=$(find . -mindepth 1 -maxdepth 1 -type f ! -name 'id_rsa.pub*' -name 'id_rsa*' -print)
	if [[ -n $SET ]]; then
	    find . -mindepth 1 -maxdepth 1 -type f ! -name 'id_rsa.pub*' -name 'id_rsa*' -print0 |
	      xargs -0 echo chown $V_FLAG "$USER_GROUP"
	fi
	SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'id_rsa.pub*' -print)
	if [[ -n $SET ]]; then
	    find . -mindepth 1 -maxdepth 1 -type f -name 'id_rsa.pub*' -print0 |
	      xargs -0 echo chown $V_FLAG "$USER_GROUP"
	fi
	SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'known_hosts*' -print)
	if [[ -n $SET ]]; then
	    find . -mindepth 1 -maxdepth 1 -type f -name 'known_hosts*' -print0 |
	      xargs -0 echo chown $V_FLAG "$USER_GROUP"
	fi
    fi 2>&1 | grep -v ' retained as '
    if [[ -n "$V_FLAG" ]]; then
	echo
    fi
fi

# Ensure that critical files have a dated copy
#
if [[ -n "$V_FLAG" ]]; then
    echo '# Ensure that critical files have a dated copy'
fi
for file in authorized_keys config id_rsa id_rsa.pub known_hosts; do

    # catch the case of a missing critical file
    #
    if [[ ! -f "$file" ]]; then
	case "$file" in
	authorized_keys|config|known_hosts)
	    if [[ -z "$I_FLAG" ]]; then
		echo "$0: Notice: not a critical problem, but $dir does not have file: $file" 1>&2
	    fi
	    ;;
	*)  if [[ -z "$I_FLAG" ]]; then
		echo "$0: Warning: $dir is missing important file: $file" 1>&2
	    fi
	    ;;
	esac
	continue
    fi

    # determine the dated filename
    #
    if [[ "${OS}" == "darwin" || "${OS}" == "macOS" ]]; then
	date_file="$file."$(ls -Tl "$file" | awk '{if($6~"Jan"){m="01"}else if($6~"Feb"){m="02"}else if($6~"Mar"){m="03"}else if($6~"Apr"){m="04"}else if($6~"May"){m="05"}else if($6~"Jun"){m="06"}else if($6~"Jul"){m="07"}else if($6~"Aug"){m="08"}else if($6~"Sep"){m="09"}else if($6~"Oct"){m="10"}else if($6~"Nov"){m="11"}else if($6~"Dec"){m="12"} else{m="mm"} if($7 < 10) {d="0"$7;} else {d=$7;} print $9 m d "." $8}' | tr -d :)
    else
	date_file="$file."$(ls --full-time "$file" | awk '{print $6, $7;}' | sed -e 's/\.[0-9]*$//' -e 's/[:-]//g' -e 's/ /./')
    fi
    if [[ -z $date_file ]]; then
	echo "$0: FATAL: cannot determinte date for file: $file" 1>&2
	exit 24
    fi

    # unless the timestamped file is a copy of the original, form it
    #
    if ! cmp -s "$file" "$date_file"; then
	if [[ -n "$V_FLAG" ]]; then
	    echo "cp -p $V_FLAG $file $date_file"
	fi
	if [[ -z "$N_FLAG" ]]; then
	    cp -p $V_FLAG "$file" "$date_file"
	    status="$?"
	    if [[ $status -ne 0 ]]; then
		echo "$0: FATAL: cp -p $V_FLAG $file $date_file, error code: $status" 1>&2
		exit 25
	    fi
	fi
    fi
done
if [[ -n "$V_FLAG" ]]; then
    echo
fi

# move all but the last dated element of certain files into OLD
#
if [[ -n "$V_FLAG" ]]; then
    echo '# Processing fileset'
fi
for file in authorized_keys config id_rsa id_rsa.pub known_hosts; do
    if [[ ! -f "$file" && -n "$I_FLAG" ]]; then
	if [[ -n "$V_FLAG" ]]; then
	    echo "# skipping the processing of: $file"
	fi
	continue
    fi
    find . -mindepth 1 -maxdepth 1 -type f \( \
      -name "$file"'.[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]' -o \
      -name "$file"'.[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9].[0-9][0-9][0-9][0-9][0-9][0-9]' -o \
      -name "$file"'.[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][a-z]' \) |
      sort -r | awk 'NR != 1 {print $0;}' | while read i; do
	if [[ -z "$N_FLAG" ]]; then
	    mv $V_FLAG "$i" OLD
	    status="$?"
	    if [[ $status -ne 0 ]]; then
		echo "$0: Warning: mv $V_FLAG $i OLD, error code: $status" 1>&2
	    fi
	elif [[ -n "$V_FLAG" ]]; then
	    echo mv $V_FLAG "$i" OLD
	fi
    done
done
if [[ -n "$V_FLAG" ]]; then
    echo
fi

# move old top level from- and no- files
#
if [[ -n "$V_FLAG" ]]; then
    echo '# Move old top level from- and no- files'
fi
find . -mindepth 1 -maxdepth 1 -type f \( -name 'from-*' -o -name 'no-*' \) -print | while read i; do
    if [[ -z "$N_FLAG" ]]; then
	mv $V_FLAG "$i" OLD
	status="$?"
	if [[ $status -ne 0 ]]; then
	    echo "$0: Warning: mv $V_FLAG $i OLD, error code: $status" 1>&2
	fi
    elif [[ -n "$V_FLAG" ]]; then
	echo mv $V_FLAG "$i" OLD
    fi
done
if [[ -n "$V_FLAG" ]]; then
    echo
fi

# clean up .nfs files in sock that are older than 1 day
#
if [[ -n "$V_FLAG" ]]; then
    echo '# Clean up .nfs files'
fi
if [[ -z "$N_FLAG" ]]; then
    SET=$(find sock -name '.nfs*' -mtime +1 -type s -print)
    if [[ -n $SET ]]; then
	find sock -name '.nfs*' -mtime +1 -type s -print0 |
	  xargs $XARGS_V -0 rm $XARGS_V -f
    fi
elif [[ -n "$V_FLAG" ]]; then
    SET=$(find sock -name '.nfs*' -mtime +1 -type s -print)
    if [[ -n $SET ]]; then
	find sock -name '.nfs*' -mtime +1 -type s -print0 |
	  xargs -0 echo rm $XARGS_V -f
    fi
fi
if [[ -n "$V_FLAG" ]]; then
    echo
fi

# All Done!!! -- Jessica Noll, Age 2
#
exit 0

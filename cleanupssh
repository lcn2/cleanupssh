#!/bin/bash
#
# cleanupssh - cleanup a .ssh directory
#
# Copyright (c) 2015-2017 by Landon Curt Noll.  All Rights Reserved.
#
# Permission to use, copy, modify, and distribute this software and
# its documentation for any purpose and without fee is hereby granted,
# provided that the above copyright, this permission notice and text
# this comment, and the disclaimer below appear in all of the following:
#
#       supporting documentation
#       source copies
#       source works derived from this source
#       binaries derived from this source or from derived source
#
# LANDON CURT NOLL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
# EVENT SHALL LANDON CURT NOLL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
# USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.
#
# chongo (Landon Curt Noll, http://www.isthe.com/chongo/index.html) /\oo/\
#
# Share and enjoy! :-)

# parse args
#
export USAGE="usage: $0 [-n] [-v] dir

    -n		do nothing (def: do)
    -v		verbose mode (def: quiet)
    -f		force cleanup if authorized_keys is missing
    -h		print this message and exit

    dir		.ssh directory to clean up"
export N_FLAG=
export V_FLAG=
export XARGS_V=
export F_FLAG=
while getopts hnvf flag; do
    case "$flag" in
    h) echo "$USAGE" 1>&2; exit 0 ;;
    n) N_FLAG="-n" ;;
    v) V_FLAG="-v" ; XARGS_V="-t" ;;
    f) F_FLAG="-f" ;;
    ?) echo "$0: FATAL: unknown or invalid -flag" 1>&2 ;
       echo "$USAGE" 1>&2 ;
       exit 1 ;;
    esac
done
shift $(( OPTIND - 1 ));
if [[ $# -ne 1 ]]; then
   echo "$USAGE" 1>&2 ;
   exit 2
fi
export dir="$1"
if [[ -z "${OS}" ]]; then
    export OS=$(uname | tr '[A-Z]' '[a-z]')
fi

# firewall
#
if [[ ! -d "$dir" ]]; then
    if [[ -z "$F_FLAG" ]]; then
	echo "$0: FATAL: not a directory: $dir" 1>&2
	exit 3
    else
	if [[ -n "$V_FLAG" ]]; then
	    echo "mkdir -p $dir"
	fi
	mkdir -p "$dir"
	if [[ ! -d "$dir" ]]; then
	    echo "$0: FATAL: cannot make directory: $dir" 1>&2
	    exit 4
	fi
    fi
fi
if [[ -z "$N_FLAG" && ! -w "$dir" ]]; then
    echo "$0: FATAL: directory not writable: $dir" 1>&2
    exit 5
fi
if [[ -n "$V_FLAG" ]]; then
    echo "cd $dir"
fi
cd "$dir"
status="$?"
if [[ $status -ne 0 ]]; then
    echo "$0: FATAL: cd $dir, error code: $status" 1>&2
    exit 6
fi
if [[ -z "$F_FLAG" && ! -f authorized_keys ]]; then
    echo "$0: FATAL: $dir is missing authorized_keys" 1>&2
    exit 7
fi
if [[ -z "$F_FLAG" && ! -f id_rsa ]]; then
    echo "$0: FATAL: $dir is missing id_rsa" 1>&2
    exit 8
fi
if [[ -z "$F_FLAG" && ! -f id_rsa.pub ]]; then
    echo "$0: FATAL: $dir is missing id_rsa.pub" 1>&2
    exit 9
fi

# form missing critical directories
#
if [[ -n "$V_FLAG" ]]; then
    echo '# processing critical directories'
fi
if [[ ! -d sock ]]; then
    if [[ -z "$N_FLAG" ]]; then
	mkdir $V_FLAG sock
	status="$?"
	if [[ ! -d sock ]]; then
	    echo "$0: FATAL cannot mkdir sock, error code: $status" 1>&2
	    exit 10
	fi
    elif [[ -n "$V_FLAG" ]]; then
	echo mkdir $V_FLAG sock
    fi
fi
if [[ -z "$N_FLAG" ]]; then
    chmod $V_FLAG 0700 sock
    status="$?"
    if [[ $status -ne 0 ]]; then
	echo "$0: FATAL: chmod 0700 sock, error code: $status" 1>&2
	exit 11
    fi
elif [[ -n "$V_FLAG" ]]; then
    echo chmod $V_FLAG 0700 sock
fi
if [[ -z "$N_FLAG" && ! -w sock ]]; then
    echo "$0: FATAL: directory not writable: sock" 1>&2
    exit 12
fi
if [[ ! -d OLD ]]; then
    if [[ -z "$N_FLAG" ]]; then
	mkdir $V_FLAG OLD
	status="$?"
	if [[ ! -d OLD ]]; then
	    echo "$0: FATAL cannot mkdir OLD, error code: $status" 1>&2
	    exit 13
	fi
    elif [[ -n "$V_FLAG" ]]; then
	echo mkdir $V_FLAG OLD
    fi
fi
if [[ -z "$N_FLAG" ]]; then
    chmod $V_FLAG 0700 OLD
    status="$?"
    if [[ $status -ne 0 ]]; then
	echo "$0: FATAL: chmod 0700 OLD, error code: $status" 1>&2
	exit 14
    fi
elif [[ -n "$V_FLAG" ]]; then
    echo chmod $V_FLAG 0700 OLD
fi
if [[ -z "$N_FLAG" && ! -w OLD ]]; then
    echo "$0: FATAL: directory not writable: OLD" 1>&2
    exit 15
fi
if [[ ! -d from ]]; then
    if [[ -z "$N_FLAG" ]]; then
	mkdir $V_FLAG from
	status="$?"
	if [[ ! -d from ]]; then
	    echo "$0: FATAL cannot mkdir from, error code: $status" 1>&2
	    exit 16
	fi
    elif [[ -n "$V_FLAG" ]]; then
	echo mkdir $V_FLAG from
    fi
fi
if [[ -z "$N_FLAG" ]]; then
    chmod $V_FLAG 0700 from
    status="$?"
    if [[ $status -ne 0 ]]; then
	echo "$0: FATAL: chmod 0700 from, error code: $status" 1>&2
	exit 17
    fi
elif [[ -n "$V_FLAG" ]]; then
    echo chmod $V_FLAG 0700 from
fi
if [[ -z "$N_FLAG" && ! -w from ]]; then
    echo "$0: FATAL: directory not writable: from" 1>&2
    exit 18
fi

# set file permissions
#
if [[ -n "$V_FLAG" ]]; then
    echo '# processing fileset permissions'
fi
if [[ -z "$N_FLAG" ]]; then
    chmod $V_FLAG 0700 .
    SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'authorized_keys*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f -name 'authorized_keys*' -print0 |
	  xargs $XARGS_V -0 chmod $V_FLAG 0400
    fi
    SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'config*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f -name 'config*' -print0 |
	  xargs $XARGS_V -0 chmod $V_FLAG 0400
    fi
    SET=$(find . -mindepth 1 -maxdepth 1 -type f ! -name 'id_rsa.pub*' -name 'id_rsa*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f ! -name 'id_rsa.pub*' -name 'id_rsa*' -print0 |
	  xargs $XARGS_V -0 chmod $V_FLAG 0400
    fi
    SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'id_rsa.pub*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f -name 'id_rsa.pub*' -print0 |
	  xargs $XARGS_V -0 chmod $V_FLAG 0444
    fi
    SET=$(find . -mindepth 1 -maxdepth 1 -type f -name 'known_hosts*' -print)
    if [[ -n $SET ]]; then
	find . -mindepth 1 -maxdepth 1 -type f -name 'known_hosts*' -print0 |
	  xargs $XARGS_V -0 chmod $V_FLAG 0664
    fi
elif [[ -n "$V_FLAG" ]]; then
    echo chmod $V_FLAG 0700 .
    find . -mindepth 1 -maxdepth 1 -type f -name 'authorized_keys*' -print0 |
      xargs -0 echo chmod $V_FLAG 0400
    find . -mindepth 1 -maxdepth 1 -type f -name 'config*' -print0 |
      xargs -0 echo chmod $V_FLAG 0400
    find . -mindepth 1 -maxdepth 1 -type f ! -name 'id_rsa.pub*' -name 'id_rsa*' -print0 |
      xargs -0 echo chmod $V_FLAG 0400
    find . -mindepth 1 -maxdepth 1 -type f -name 'id_rsa.pub*' -print0 |
      xargs -0 echo chmod $V_FLAG 0444
    find . -mindepth 1 -maxdepth 1 -type f -name 'known_hosts*' -print0 |
      xargs -0 echo chmod $V_FLAG 0664
fi

# Insure that critical files have a dated copy
#
for file in authorized_keys config id_rsa id_rsa.pub known_hosts; do

    # determine the dated filename
    #
    if [[ "${OS}" == "darwin" || "${OS}" == "macOS" ]]; then
	date_file="$file."$(ls -Tl "$file" | awk '{if($6~"Jan"){m="01"}else if($6~"Feb"){m="02"}else if($6~"Mar"){m="03"}else if($6~"Apr"){m="04"}else if($6~"May"){m="05"}else if($6~"Jun"){m="06"}else if($6~"Jul"){m="07"}else if($6~"Aug"){m="08"}else if($6~"Sep"){m="09"}else if($6~"Oct"){m="10"}else if($6~"Nov"){m="11"}else if($6~"Dec"){m="12"} else{m="mm"} if($7 < 10) {d="0"$7;} else {d=$7;} print $9 m d "." $8}' | tr -d :)
    else
	date_file="$file."$(ls --full-time "$file" | awk '{print $6, $7;}' | sed -e 's/\.[0-9]*$//' -e 's/[:-]//g' -e 's/ /./')
    fi
    if [[ -z $date_file ]]; then
	echo "$0: FATAL: cannot determinte date for file: $file" 1>&2
	exit 19
    fi

    # unless the timestamped file is a copy of the original, form it
    #
    if ! cmp -s "$file" "$date_file"; then
	if [[ -n "$V_FLAG" ]]; then
	    echo "cp -p $file $date_file"
	fi
	if [[ -z "$N_FLAG" ]]; then
	    cp -p "$file" "$date_file"
	    status="$?"
	    if [[ $status -ne 0 ]]; then
		echo "$0: FATAL: cp -p $file $date_file, error code: $status" 1>&2
		exit 20
	    fi
	fi
    fi
done

# move all but the last dated element of certain files into OLD
#
for file in authorized_keys config id_rsa id_rsa.pub known_hosts; do
    if [[ -n "$V_FLAG" ]]; then
	echo "# processing fileset: $file"
    fi
    find . -mindepth 1 -maxdepth 1 -type f \( \
      -name "$file"'.[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]' -o \
      -name "$file"'.[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9].[0-9][0-9][0-9][0-9][0-9][0-9]' -o \
      -name "$file"'.[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][a-z]' \) |
      sort -r | awk 'NR != 1 {print $0;}' | while read i; do
    if [[ -z "$N_FLAG" ]]; then
	mv $V_FLAG "$i" OLD
	status="$?"
	if [[ $status -ne 0 ]]; then
	    echo "$0: Warning: mv $V_FLAG $i OLD, error code: $status" 1>&2
	fi
    elif [[ -n "$V_FLAG" ]]; then
	echo mv $V_FLAG "$i" OLD
    fi
    done
done

# old top level from- and no-
#
find . -mindepth 1 -maxdepth 1 -type f \( -name 'from-*' -o -name 'no-*' \) -print |
    while read i; do
    if [[ -z "$N_FLAG" ]]; then
	mv $V_FLAG "$i" OLD
	status="$?"
	if [[ $status -ne 0 ]]; then
	    echo "$0: Warning: mv $V_FLAG $i OLD, error code: $status" 1>&2
	fi
    elif [[ -n "$V_FLAG" ]]; then
	echo mv $V_FLAG "$i" OLD
    fi
    done

# clean up .nfs files in sock that are older than 1 day
#
if [[ "${OS}" == "darwin" || "${OS}" == "macOS" ]]; then
    find sock -name '.nfs*' -mtime +1 -type s -print0 | xargs -0 rm -f
else
    find sock -name '.nfs*' -mtime +1 -type s -print0 | xargs -0 -r rm -f
fi

# All Done!!! - Jessica Noll, Age 2
#
exit 0

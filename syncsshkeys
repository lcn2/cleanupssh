#!/bin/bash
#
# syncsshkeys - sync /etc/ssh & ~root/.ssh with ssh key backup tree
#
# Copyright (c) 2015 by Landon Curt Noll.  All Rights Reserved.
#
# Permission to use, copy, modify, and distribute this software and
# its documentation for any purpose and without fee is hereby granted,
# provided that the above copyright, this permission notice and text
# this comment, and the disclaimer below appear in all of the following:
#
#       supporting documentation
#       source copies
#       source works derived from this source
#       binaries derived from this source or from derived source
#
# LANDON CURT NOLL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
# EVENT SHALL LANDON CURT NOLL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
# USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.
#
# chongo (Landon Curt Noll, http://www.isthe.com/chongo/index.html) /\oo/\
#
# Share and enjoy! :-)

# parse args
#
BKUPTREE="/usr/global/backup/ssh/current/$HOSTNAME"
USAGE="usage: $0 [-h] [-n] [-v] [-b bkuptree] [-r chroot] [-f] [-e] [-w whoami]
		 [-g ssh_keys] [-c]

	-h		print this help message and then exit (def: don't)
	-n		don't change any files, just echo commands (def: change)
	-v		verbose rsync and debug messages (def: be silent)
	-b bkuptree	ssh key backup tree directory
			    (def: $BKUPTREE)
	-r chroot	prepend chroot to /etc/ssh & /root/.ssh (def: don't)
	-f 		force backup into bkuptree
			   (def: restore if bkuptree is a dir)
	-e		bkuptree already must exist (def: create as needed)
	-w whoami	use hostname: whoami (def: use $HOSTNANE)
	-g ssh_keys	change the chgrp group (def: chgrp ssh_keys)
	-c		do not chgrp system key files (def: do chgrp)

    NOTE: Without -f, if this bkuptree directory exists, then
	  system & root ssh files will be restored from the bkuptree,
	  which by default is:

	    $BKUPTREE

	  Without -e, without -f, and
	    if the bkuptree directory does NOT exist, then
	  instead of a restore a backup into the bkuptree directory will occur.

	  With -e, without -f, and
	    if the bkuptree directory does NOT exist, then
	  this command will abort.

	  Use of -e without -f forces a RESTORE ONLY mode.

    NOTE: With -f, system & root ssh files will be backuped into bkuptree,
	  which by default is:

	    $BKUPTREE

	  Without -e, with -f, and
	    if the bkuptree directory does NOT exist, then
	  the bkuptree (and its sub-dirs) will attempted to be created.

	  With -e, with -f, and
	    if the bkuptree directory does NOT exist, then
	  this command will abort.

	  Use of -e with -f forces a BACKUP ONLY mode.

    NOTE: System ssh files are under the /etc/ssh directory.
	  Root ssh files are under the /root/.ssh directory.
	  Those directories, in turn, will be under the chroot & bkuptree dirs.

    NOTE: When restoring, and unless prevented by -c, system key files under
	  /etc/ssh will be chgrp-ed with the ssh_key group.

    NOTE: When backing up, and unless prevented by -c, system key files under:

	    $BKUPTREE

	  will be chgrp-ed with the ssh_key group.

    NOTE: System key files are any *_key file that exists.
	  Th most common System key files are:

	    ssh_host_ecdsa_key ssh_host_ed25519_key ssh_host_rsa_key"
GROUP="ssh_keys"
N_FLAG=
V_FLAG=
TIMESTAMP=$(date '+%Y%m%d.%H%M%S')
CHROOT=		# effectively "/"
F_FLAG=
C_FLAG=
E_FLAG=
set -- $(/usr/bin/getopt hnvb:r:fw:g:ce $*)
if [[ $? != 0 ]]; then
    echo "$0: FATAL: unknown or invalid -flag" 1>&2
    echo "$USAGE" 1>&2
    exit 3
fi
for i in $*; do
    case $i in
    -h) echo "$USAGE" 1>&2; exit 0 ;;
    -n) N_FLAG="-n" ;;
    -v) V_FLAG="-v" ;;
    -b) BKUPTREE="$2" ; shift ;;
    -r) CHROOT="$2" ; shift ;;
    -f) F_FLAG="-f" ;;
    -w) HOSTNAME="$2";
	BKUPTREE="/usr/global/backup/ssh/current/$2";
	shift ;;
    -g) GROUP="$2" ; shift ;;
    -c) C_FLAG="-c" ;;
    -e) E_FLAG="-e" ;;
    --) shift; break ;;
    esac
    shift
done
if [[ $# != 0 ]]; then
    echo "$USAGE" 1>&2
    exit 4
fi
ORIG_F_FLAG="$F_FLAG"
export N_FLAG V_FLAG BKUPTREE CHROOT F_FLAG TIMESTAMP ORIG_F_FLAG
export GROUP C_FLAG E_FLAG
if [[ -n "$V_FLAG" && -n "$E_FLAG" ]]; then
    if [[ -n "$F_FLAG" ]]; then
	echo "$0: Notice: Use of -e with -f forces a BACKUP ONLY mode."
    else
	echo "$0: Notice: Use of -e without -f forces a RESTORE ONLY mode."
    fi
fi

# setup
#
ETC_SSH_BKUP="$BKUPTREE/etc/ssh"
ORIG_ETC_SSH_BKUP="$ETC_SSH_BKUP"
export ETC_SSH_BKUP ORIG_ETC_SSH_BKUP
ROOT_SSH_BKUP="$BKUPTREE/root/.ssh"
ORIG_ROOT_SSH_BKUP="$ROOT_SSH_BKUP"
export ROOT_SSH_BKUP ORIG_ROOT_SSH_BKUP

# Abort if -e and no bkuptree or critcal bkuptree subdirs
#
if [[ -n "$E_FLAG" ]]; then
    if [[ ! -d "$BKUPTREE" ]]; then
	echo "$0: FATAL: -e and bkuptree is not a directory: $BKUPTREE" 1>&2
	echo "$0: FATAL: aborting backup exit code: 5" 1>&2
	exit 5
    elif [[ ! -d "$ETC_SSH_BKUP" ]]; then
	echo "$0: FATAL: -e and bkuptree/etc/ssh is not a directory: $ETC_SSH_BKUP" 1>&2
	echo "$0: FATAL: aborting backup exit code: 6" 1>&2
	exit 6
    elif [[ ! -d "$ROOT_SSH_BKUP" ]]; then
	echo "$0: FATAL: -e and bkuptree/root/.ssh is not a directory: $ROOT_SSH_BKUP" 1>&2
	echo "$0: FATAL: aborting backup exit code: 7" 1>&2
	exit 7
    fi
    if [[ -n "$V_FLAG" ]]; then
	echo "$0: Notice: required bkuptree directory exists: $BKUPTREE"
	echo "$0: Notice: required bkuptree/etc/ssh directory exists: $ETC_SSH_BKUP"
	echo "$0: Notice: required bkuptree/root/.ssh directory exists: $ROOT_SSH_BKUP"
    fi

# Report on missing directories if -v and no -e.
#
elif [[ -n "$V_FLAG" ]]; then
    if [[ ! -e "$BKUPTREE" ]]; then
	echo "$0: Notice: bkuptree directory does not exist: $BKUPTREE"
	echo "$0: Notice: will soon attempt to create: $BKUPTREE"
    elif [[ ! -d "$BKUPTREE" ]]; then
	echo "$0: Warning: bkuptree exists but is not a directory: $BKUPTREE"
    else
	echo "$0: Notice: is a directory: $BKUPTREE"
    fi
    if [[ ! -e "$ETC_SSH_BKUP" ]]; then
	echo "$0: Notice: bkuptree/etc/ssh directory does not exist: $ETC_SSH_BKUP"
	echo "$0: Notice: will soon attempt to create: $ETC_SSH_BKUP"
	if [[ ! -w "$BKUPTREE" ]]; then
	    echo "$0: Warning: may not be able to create due to non-writable directory: $BKUPTREE"
	fi
    elif [[ ! -d "$ETC_SSH_BKUP" ]]; then
	echo "$0: Warning: bkuptree/etc/ssh exists but is not a directory: $ETC_SSH_BKUP"
	if [[ ! -w "$BKUPTREE" ]]; then
	    echo "$0: Warning: may not be able to create due to non-writable directory: $BKUPTREE"
	fi
    elif [[ ! -w "$ETC_SSH_BKUP" ]]; then
	echo "$0: Warning: bkuptree/etc/ssh is a non-writbale directory: $ETC_SSH_BKUP"
    fi
    if [[ ! -e "$ROOT_SSH_BKUP" ]]; then
	echo "$0: Notice: bkuptree/root/.ssh directory does not exist: $ROOT_SSH_BKUP"
	echo "$0: Notice: will soon attempt to create: $ROOT_SSH_BKUP"
	if [[ ! -w "$BKUPTREE" ]]; then
	    echo "$0: Warning: may not be able to create due to non-writable directory: $BKUPTREE"
	fi
    elif [[ ! -e "$ROOT_SSH_BKUP" ]]; then
	echo "$0: Warning: bkuptree/root/.ssh exists but is not a directory: $ROOT_SSH_BKUP"
	if [[ ! -w "$BKUPTREE" ]]; then
	    echo "$0: Warning: may not be able to create due to non-writable directory: $BKUPTREE"
	fi
    elif [[ ! -w "$ROOT_SSH_BKUP" ]]; then
	echo "$0: Warning: bkuptree/root/.ssh is a non-writbale directory: $ROOT_SSH_BKUP"
    fi
fi

# backup or restore of /etc/ssh
#
ETC_SSH_OK=
export ETC_SSH_OK
if [[ -n "$V_FLAG" ]]; then
    echo "$0: Notice: on $HOSTNAME ensure $CHROOT/etc/ssh is a clone of $ETC_SSH_BKUP"
fi
if [[ ! -d "$ETC_SSH_BKUP" || -n "$F_FLAG" ]]; then

    # backup new /etc/ssh or forced backup of exising /etc/ssh
    #
    if [[ ! -d "$ETC_SSH_BKUP" ]]; then
	echo "$0: Notice: not a directory: $ETC_SSH_BKUP" 1>&2
	if [[ ! -d "$CHROOT/etc/ssh" ]]; then
	    echo "$0: FATAL: no directory to backup: $CHROOT/etc/ssh" 1>&2
	    echo "$0: FATAL: aborting backup exit code: 8" 1>&2
	    exit 8
	fi
	ETC_SSH_BKUP="$ETC_SSH_BKUP.$TIMESTAMP"
	if [[ -n "$V_FLAG" ]]; then
	   echo "$0: Notice: will create a temporary backup directory: $ETC_SSH_BKUP"
	fi
	if [[ -z "$N_FLAG" ]]; then
	    mkdir -p "$ETC_SSH_BKUP"
	    if [[ ! -d "$ETC_SSH_BKUP" ]]; then
		echo "$0: FATAL: unable to create temporary backup directory: $ETC_SSH_BKUP" 1>&2
		echo "$0: FATAL: aborting backup exit code: 9" 1>&2
		exit 9
	    fi
	fi
	echo "$0: Notice: temporarly turning on -f flag: forcing backup of $CHROOT/etc/ssh" 1>&2
	F_FLAG="-f"
    fi

    # perform rsync backup from /etc/ssh into bkuptree/etc/ssh
    #
    # FYI: regarding sync args used:
    #
    #	-a		archive: clone and compare mode
    #	--delete	remove dest things not found in src
    #	-0		protect against bogus filename chars (newlines, whitespace, etc.)
    #	-v		be verbose (if -v was given as an arg)
    #
    if [[ -n "$V_FLAG" ]]; then
	if [[ -n "$F_FLAG" ]]; then
	    echo "$0: Notice: foring backup do to use of -f"
	fi
	echo "$0: Notice: on $HOSTNAME about to backup $CHROOT/etc/ssh/ to $ETC_SSH_BKUP"
	echo rsync -a --delete -0 $V_FLAG $N_FLAG "$CHROOT/etc/ssh/" "$ETC_SSH_BKUP"
    fi
    if [[ -z "$N_FLAG" ]]; then
	rsync -a --delete -0 $V_FLAG "$CHROOT/etc/ssh/" "$ETC_SSH_BKUP"
	status="$?"
    else
	rsync -a --delete -0 $V_FLAG -n "$CHROOT/etc/ssh/" "$ETC_SSH_BKUP"
	status=0
    fi

    # rsync success or failure processing
    #
    if [[ ! -d "$ETC_SSH_BKUP" ]]; then
	echo "$0: Warning: status: $status unable create backup directory $ETC_SSH_BKUP" 1>&2
    elif [[ "$status" -ne 0 ]]; then
	echo "$0: Warning: status: $status backup failed for $CHROOT/etc/ssh to $ETC_SSH_BKUP" 1>&2
    else
	if [[ -n "$V_FLAG" ]]; then
	    echo "$0: Notice: on $HOSTNAME successful backup of $CHROOT/etc/ssh to $ETC_SSH_BKUP"
	fi
	ETC_SSH_OK=true
    fi
    if [[ -n "$ETC_SSH_OK" && "$ETC_SSH_BKUP" != "$ORIG_ETC_SSH_BKUP" ]]; then
	if [[ -n "$V_FLAG" ]]; then
	    echo "$0: Notice: about to make temporary backup directory permanent: $ETC_SSH_BKUP" 1>&2
	fi
	if [[ -e "$ORIG_ETC_SSH_BKUP" ]]; then
	    echo "$0: Warning: original backup directory was found: $ORIG_ETC_SSH_BKUP" 1>&2
	    echo "$0: Warning: leaving temporary backup directory in place: $ETC_SSH_BKUP" 1>&2
	    ETC_SSH_OK=
	else
	    mv -f "$ETC_SSH_BKUP" "$ORIG_ETC_SSH_BKUP"
	    status="$?"
	    if [[ ! -d "$ORIG_ETC_SSH_BKUP" ]]; then
		echo "$0: Warning: status: $status move of temporary to permanent failed, $ORIG_ETC_SSH_BKUP not found" 1>&2
		ETC_SSH_OK=
	    elif [[ "$status" -ne 0 ]]; then
		echo "$0: Warning: status: $status backup failed mv -f $ETC_SSH_BKUP $ORIG_ETC_SSH_BKUP" 1>&2
		ETC_SSH_OK=
	    else
		if [[ -n "$V_FLAG" ]]; then
		    echo "$0: Notice: temporary backup directory now permanant: $ORIG_ETC_SSH_BKUP" 1>&2
		fi
		ETC_SSH_BKUP="$ORIG_ETC_SSH_BKUP"
	    fi
	fi
    fi
    if [[ "$F_FLAG" != "$ORIG_F_FLAG" ]]; then
	echo "$0: Notice: turning temporary setting of the -f flag back off" 1>&2
	F_FLAG="$ORIG_F_FLAG"
    fi

    # chgrp system key files of all was OK and no -c
    #
    if [[ -z "$C_FLAG" ]]; then
	if [[ -z "$ETC_SSH_OK" ]]; then
	    echo "$0: Warning: due to issues, skipping chgrp $GROUP system key files under $ETC_SSH_BKUP" 1>&2
	else
	    if [[ -n "$V_FLAG" ]]; then
		if [[ -z "$N_FLAG" ]]; then
		    echo "$0: Notice: will attempt to chgrp $GROUP system key files under $ETC_SSH_BKUP"
		    find "$ETC_SSH_BKUP" -type f -mindepth 1 -maxdepth 1 -iname '*_key' -print0 |
			xargs -0 --max-args=1 --no-run-if-empty --verbose chgrp "$GROUP"
		else
		    echo "$0: Notice: do to -n, will simulate chgrp $GROUP system key files under $ETC_SSH_BKUP"
		    find "$ETC_SSH_BKUP" -type f -mindepth 1 -maxdepth 1 -iname '*_key' -print0 |
			xargs -0 --max-args=1 --no-run-if-empty --verbose echo chgrp "$GROUP"
		fi
	    elif [[ -z "$N_FLAG" ]]; then
		find "$ETC_SSH_BKUP" -type f -mindepth 1 -maxdepth 1 -iname '*_key' -print0 |
		    xargs -0 --max-args=1 --no-run-if-empty chgrp "$GROUP"
	    fi
	fi
    elif [[ -n "$V_FLAG" ]]; then
	echo "$0: Notice: -c disabled chgrp $GROUP of system key files under $ETC_SSH_BKUP" 1>&2
    fi

else

    # perform rsync restore from bkuptree/etc/ssh to /etc/ssh
    #
    # FYI: regarding sync args used:
    #
    #	-a		archive: clone and compare mode
    #	--delete	remove dest things not found in src
    #	-0		protect against bogus filename chars (newlines, whitespace, etc.)
    #	-v		be verbose (if -v was given as an arg)
    #
    if [[ -n "$V_FLAG" ]]; then
	echo "$0: Notice: on $HOSTNAME about to restore $ETC_SSH_BKUP/ to $CHROOT/etc/ssh"
	echo rsync -a --delete -0 $V_FLAG $N_FLAG "$ETC_SSH_BKUP/" "$CHROOT/etc/ssh"
    fi
    if [[ -z "$N_FLAG" ]]; then
	rsync -a --delete -0 $V_FLAG "$ETC_SSH_BKUP/" "$CHROOT/etc/ssh"
	status="$?"
    else
	rsync -a --delete -0 $V_FLAG -n "$ETC_SSH_BKUP/" "$CHROOT/etc/ssh"
	status=0
    fi

    # rsync success or failure processing
    #
    if [[ ! -d "$CHROOT/etc/ssh" ]]; then
	echo "$0: Warning: status: $status unable to create $CHROOT/etc/ssh for $HOSTNAME from $ETC_SSH_BKUP" 1>&2
    elif [[ "$status" -ne 0 ]]; then
       echo "$0: Warning: status: $status restore failed for $CHROOT/etc/ssh to $ETC_SSH_BKUP" 1>&2
    else
	if [[ -n "$V_FLAG" ]]; then
	    echo "$0: Notice: on $HOSTNAME sucessful restore of $ETC_SSH_BKUP to $CHROOT/etc/ssh"
	fi
	ETC_SSH_OK=true
    fi

    # chgrp system key files of all was OK and no -c
    #
    if [[ -z "$C_FLAG" ]]; then
	if [[ -z "$ETC_SSH_OK" ]]; then
	    echo "$0: Warning: due to issues, skipping chgrp $GROUP system key files under $CHROOT/etc/ssh" 1>&2
	else
	    if [[ -n "$V_FLAG" ]]; then
		if [[ -z "$N_FLAG" ]]; then
		    echo "$0: Notice: will attempt to chgrp $GROUP system key files under $CHROOT/etc/ssh"
		    find "$CHROOT/etc/ssh" -type f -mindepth 1 -maxdepth 1 -iname '*_key' -print0 |
			xargs -0 --max-args=1 --no-run-if-empty --verbose chgrp "$GROUP"
		else
		    echo "$0: Notice: due to -n, will simulate chgrp $GROUP system key files under $CHROOT/etc/ssh"
		    find "$CHROOT/etc/ssh" -type f -mindepth 1 -maxdepth 1 -iname '*_key' -print0 |
			xargs -0 --max-args=1 --no-run-if-empty --verbose echo chgrp "$GROUP"
		fi
	    elif [[ -z "$N_FLAG" ]]; then
		find "$CHROOT/etc/ssh" -type f -mindepth 1 -maxdepth 1 -iname '*_key' -print0 |
		    xargs -0 --max-args=1 --no-run-if-empty chgrp "$GROUP"
	    fi
	fi
    elif [[ -n "$V_FLAG" ]]; then
	echo "$0: Notice: -c disabled chgrp $GROUP of system key files under $CHROOT/etc/ssh" 1>&2
    fi
fi
#
# paranoia - compare /etc/ssh with bkuptree/etc/ssh
#
if [[ -n "$ETC_SSH_OK" ]]; then
    if [[ -n "$V_FLAG" ]]; then
	echo diff -r "$CHROOT/etc/ssh" "$ETC_SSH_BKUP"
    fi
    diff -r "$CHROOT/etc/ssh" "$ETC_SSH_BKUP" >/dev/null 2>&1
    status="$?"
    if [[ "$status" -ne 0 ]]; then
	echo "$0: Warning: diff status: $status, $CHROOT/etc/ssh differs from $ETC_SSH_BKUP"
	ETC_SSH_OK=
    elif [[ -n "$V_FLAG" ]]; then
	echo "$0: Notice: on $HOSTNAME contents of $CHROOT/etc/ssh matches $ETC_SSH_BKUP"
    fi
fi

# backup or restore of /root/.ssh
#
ROOT_SSH_OK=
export ROOT_SSH_OK
if [[ -n "$V_FLAG" ]]; then
    echo "$0: Notice: on $HOSTNAME ensure $CHROOT/root/.ssh is a clone of $ROOT_SSH_BKUP"
fi
if [[ ! -d "$ROOT_SSH_BKUP" || -n "$F_FLAG" ]]; then

    # backup new /root/.ssh or force backup of existing /root/.ssh
    #
    if [[ ! -d "$ROOT_SSH_BKUP" ]]; then
	echo "$0: Notice: not a directory: $ROOT_SSH_BKUP" 1>&2
	if [[ ! -d "$CHROOT/root/.ssh" ]]; then
	    echo "$0: Notice: no directory to backup, about to create: $CHROOT/root/.ssh" 1>&2
	    if [[ -z "$N_FLAG" ]]; then
		mkdir -p "$CHROOT/root/.ssh"
		status="$?"
		if [[ ! -d "$CHROOT/root/.ssh" ]]; then
		    echo "$0: FATAL: status: $status could not create: $CHROOT/root/.ssh" 1>&2
		    echo "$0: FATAL: aborting backup exit code: 10" 1>&2
		    exit 10
		elif [[ "$status" -ne 0 ]]; then
		    echo "$0: FATAL: status: $status could not create: $CHROOT/root/.ssh" 1>&2
		    echo "$0: FATAL: aborting backup exit code: 11" 1>&2
		    exit 11
		else
		    echo "$0: Notice: about to chmod 0700 $CHROOT/root/.ssh"
		    chmod 0700 "$CHROOT/root/.ssh"
		    status="$?"
		    if [[ "$status" -ne 0 ]]; then
			echo "$0: FATAL: status: $status failed to chmod 0700 $CHROOT/root/.ssh" 1>&2
			echo "$0: FATAL: aborting backup exit code: 12" 1>&2
			exit 12
		    fi
		fi
	    fi
	fi
	ROOT_SSH_BKUP="$ROOT_SSH_BKUP.$TIMESTAMP"
	if [[ -n "$V_FLAG" ]]; then
	   echo "$0: Notice: will create a temporary backup directory: $ROOT_SSH_BKUP"
	fi
	if [[ -z "$N_FLAG" ]]; then
	    mkdir -p "$ROOT_SSH_BKUP"
	    if [[ ! -d "$ROOT_SSH_BKUP" ]]; then
		echo "$0: FATAL: unable to create temporary backup directory: $ROOT_SSH_BKUP" 1>&2
		echo "$0: FATAL: aborting backup exit code: 13" 1>&2
		exit 13
	    fi
	fi
	echo "$0: Notice: temporarly turning on -f flag: forcing backup of /root/.ssh" 1>&2
	F_FLAG="-f"
    fi

    # perform rsync backup from /root/.ssh into bkuptree/root/.ssh
    #
    # FYI: regarding sync args used:
    #
    #	-a		archive: clone and compare mode
    #	--delete	remove dest things not found in src
    #	-0		protect against bogus filename chars (newlines, whitespace, etc.)
    #	-v		be verbose (if -v was given as an arg)
    #
    if [[ -n "$V_FLAG" ]]; then
	if [[ -n "$F_FLAG" ]]; then
	    echo "$0: Notice: foring backup do to use of $F_FLAG"
	fi
	echo "$0: Notice: on $HOSTNAME about to backup $CHROOT/root/.ssh/ to $ROOT_SSH_BKUP"
	echo rsync -a --delete -0 --exclude 'sock-*' $V_FLAG $N_FLAG "$CHROOT/root/.ssh/" "$ROOT_SSH_BKUP"
    fi
    if [[ -z "$N_FLAG" ]]; then
	rsync -a --delete -0 --exclude 'sock-*' $V_FLAG "$CHROOT/root/.ssh/" "$ROOT_SSH_BKUP"
	status="$?"
    else
	rsync -a --delete -0 --exclude 'sock-*' $V_FLAG -n "$CHROOT/root/.ssh/" "$ROOT_SSH_BKUP"
	status=0
    fi

    # rsync success or failure processing
    #
    if [[ ! -d "$ROOT_SSH_BKUP" ]]; then
	echo "$0: Warning: status: $status unable create backup directory $ROOT_SSH_BKUP" 1>&2
    elif [[ "$status" -ne 0 ]]; then
	echo "$0: Warning: status: $status backup failed for $CHROOT/root/.ssh to $ROOT_SSH_BKUP" 1>&2
    else
	if [[ -n "$V_FLAG" ]]; then
	    echo "$0: Notice: on $HOSTNAME successful backup of $CHROOT/root/.ssh to $ROOT_SSH_BKUP"
	fi
	ROOT_SSH_OK=true
    fi
    if [[ -n "$ROOT_SSH_OK" && "$ROOT_SSH_BKUP" != "$ORIG_ROOT_SSH_BKUP" ]]; then
	if [[ -n "$V_FLAG" ]]; then
	    echo "$0: Notice: about to make temporary backup directory permanent: $ROOT_SSH_BKUP" 1>&2
	fi
	if [[ -e "$ORIG_ROOT_SSH_BKUP" ]]; then
	    echo "$0: Warning: original backup directory was found: $ORIG_ROOT_SSH_BKUP" 1>&2
	    echo "$0: Warning: leaving temporary backup directory in place: $ROOT_SSH_BKUP" 1>&2
	    ROOT_SSH_OK=
	else
	    mv -f "$ROOT_SSH_BKUP" "$ORIG_ROOT_SSH_BKUP"
	    status="$?"
	    if [[ ! -d "$ORIG_ROOT_SSH_BKUP" ]]; then
		echo "$0: Warning: status: $status move of temporary to permanent failed, $ORIG_ROOT_SSH_BKUP not found" 1>&2
		ROOT_SSH_OK=
	    elif [[ "$status" -ne 0 ]]; then
		echo "$0: Warning: status: $status backup failed mv -f $ROOT_SSH_BKUP $ORIG_ROOT_SSH_BKUP" 1>&2
		ROOT_SSH_OK=
	    else
		if [[ -n "$V_FLAG" ]]; then
		    echo "$0: Notice: temporary backup directory now permanant: $ORIG_ROOT_SSH_BKUP" 1>&2
		fi
		ROOT_SSH_BKUP="$ORIG_ROOT_SSH_BKUP"
	    fi
	fi
    fi
    if [[ "$F_FLAG" != "$ORIG_F_FLAG" ]]; then
	echo "$0: Notice: turning temporary setting of the -f flag back off" 1>&2
	F_FLAG="$ORIG_F_FLAG"
    fi

else

    # perform rsync restore from bkuptree/root/.ssh to /root/.ssh
    #
    # FYI: regarding sync args used:
    #
    #	-a		archive: clone and compare mode
    #	--delete	remove dest things not found in src
    #	-0		protect against bogus filename chars (newlines, whitespace, etc.)
    #	-v		be verbose (if -v was given as an arg)
    #
    if [[ -n "$V_FLAG" ]]; then
	echo "$0: Notice: on $HOSTNAME about to restore $ETC_SSH_BKUP/ to $CHROOT/root/.ssh"
	echo rsync -a --delete -0 --exclude 'sock-*' $V_FLAG $N_FLAG "$ROOT_SSH_BKUP/" "$CHROOT/root/.ssh"
    fi
    if [[ -z "$N_FLAG" ]]; then
	rsync -a --delete -0 --exclude 'sock-*' $V_FLAG "$ROOT_SSH_BKUP/" "$CHROOT/root/.ssh"
	status="$?"
    else
	rsync -a --delete -0 --exclude 'sock-*' $V_FLAG -n "$ROOT_SSH_BKUP/" "$CHROOT/root/.ssh"
	status=0
    fi

    # rsync success or failure processing
    #
    if [ ! -d "$CHROOT/root/.ssh" ]; then
	echo "$0: Warning: status: $status unable to create $CHROOT/root/.ssh for $HOSTNAME from $ROOT_SSH_BKUP" 1>&2
    elif [ "$status" -ne 0 ]; then
       echo "$0: Warning: status: $status restore failed for $CHROOT/root/.ssh to $ROOT_SSH_BKUP" 1>&2
    else
	if [[ -n "$V_FLAG" ]]; then
	    echo "$0: Notice: on $HOSTNAME sucessful restore of $ROOT_SSH_BKUP to $CHROOT/root/.ssh"
	fi
	ROOT_SSH_OK=true
    fi
fi
#
# paranoia - compare /root/.ssh with bkuptree/root/.ssh
#
if [[ -n "$ROOT_SSH_OK" ]]; then
    if [[ -n "$V_FLAG" ]]; then
	echo diff --exclude='sock-*' -r "$CHROOT/root/.ssh" "$ROOT_SSH_BKUP"
    fi
    diff --exclude='sock-*' -r "$CHROOT/root/.ssh" "$ROOT_SSH_BKUP" >/dev/null 2>&1
    status="$?"
    if [[ "$status" -ne 0 ]]; then
	echo "$0: Warning: diff status: $status, $CHROOT/root/.ssh differs from $ROOT_SSH_BKUP"
	ROOT_SSH_OK=
    elif [[ -n "$V_FLAG" ]]; then
	echo "$0: Notice: on $HOSTNAME contents of $CHROOT/root/.ssh matches $ROOT_SSH_BKUP"
    fi
fi

# All Done!!! - Jessica Noll, Age 2
#
if [[ -z "$ETC_SSH_OK" ]]; then
    echo "$0: Warning: on $HOSTNAME processing of $CHROOT/etc/ssh was not successful" 1>&2
    exit 1
fi
if [[ -z "$ROOT_SSH_OK" ]]; then
    echo "$0: Warning: on $HOSTNAME processing of $CHROOT/root/.ssh was not successful" 1>&2
    exit 2
fi
exit 0
